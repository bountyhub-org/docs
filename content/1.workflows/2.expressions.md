# Expressions

Expressions are implemented as a way for you to describe the conditional, or to evaluate something based on the context you are in.

Currently, expressions are used in 3 places:

- Scheduling (`on.expr`, statement defines the expression that should evaluate to a boolean value)
- Conditional step (`scans.[id].steps[].if`, allows steps to be conditionally executed. It should evaluate to a boolean value)
- Run expression (Within a run, you can use template expression in form of `${{ expression }}`. Expression should evaluate to a string, or an integer value.)

## Syntax

We use a language called CEL. If you've ever used languages that look like C, you'll find this one pretty familiar.

In BountyHub, we handle expressions with something we call Context.

Think of `Context` as a state. State is populated with predefined variables and structures. Then that state is used to evaluate the expression and get a result of some type.

For that reason, it is important that you are aware which expressions should evaluate to boolean values, and which ones should evaluate to a string value.

Let's walk through some examples to get familiar with the expression language.

### Check if the latest job is successful

In order to do the check, we first need to ensure that the job has at least one scan. Therefore, the check we should start with is: `size(scans.example) > 0`.

Next, we need to figure out if the latest job that belong to the `example` scan is successful. Since the status field is of type `string`, and since jobs are ordered in descending order based on ID (last job is the first element of the array), the check should look something similar to this: `scans.example[0].status == 'succeeded'`.

Let's put those together within our workflow:

```yaml
scans:
  first_scan:
    on:
      dispatch: {}
    # ...
  second_scan:
    on:
      expr: size(scans.first_scan) > 0 && scans.first_scan[0].status == 'succeeded'
    # ...
```

Since CEL is strongly typed, the array access to `[0]` would cause problems if there are no scans associated with our `first-scan`.

For those of you that are programmers, you already know this. For the ones who are not, please let me know if you have trouble with this syntax. If there is a strong need, we may introduce helper functions to wrap this and allow you to write expressions easier.

### Check if there is a diff on the job

Sometimes, we only want to run scans if something has changed between runs. Let's start again by breaking down the problem.

We need at least two scans. Therefore, the size of the scans should be at least 2. So we have `size(scans.example) > 2`.

Next, we need to figure out if there is something that has changed in the output. The way we can determine that, is through the field called `nonce`. More on that you can read in the [context section](/workflows/expressions#context-variables).

The `nonce` field is sha512 calculated hash of the output. The nature of the hash function is that if anything changes within the output, it will change the hash (I know, there are hash collisions, but there are no known hash collision for sha512 :)).

Since `nonce` is of type `string`, we can easily test it by running: `scans.example[0].nonce != scans.example[1].nonce`.

```yaml
scans:
  first_scan:
    on:
      dispatch: {}
    # ...
  second_scan:
    on:
      expr: size(scans.first_scan) > 2 && scans.first_scan[0].nonce != scans.first_scan[1].nonce
    # ...
```

We can go even further. If last two successful scans were successful, and they have the diff, it would look like this:

```yaml
scans:
  first_scan:
    on:
      dispatch: {}
    # ...
  second_scan:
    on:
      expr: |
        size(scans.first_scan) > 2 
        && scans.first_scan[0].status == 'succeeded'
        && scans.first_scan[1].status == 'succeeded'
        && scans.first_scan[0].nonce != scans.first_scan[1].nonce
    # ...
```

### Run step if other step is skipped

You can decide to have a conditional step. If that step evaluates to `false`, it will be skipped.

Let's say that you want to run something if the target step is skipped.

```yaml
scans:
  example:
    # rest of the fields
    steps:
      - run: echo "This is a first step"
        shell: bash
      # Skip this step if this is the first invocation of this scan
      - if: size(scans.example) == 0 // Skipped on the first run
        run: echo "This will run when there is at least one instance of the run"
        shell: bash
      - if: steps[1].status == 'skipped'
        run: echo "This will run on the first invocation of this scan"
        shell: bash
```

### Run step always

If you want to run some step regardless of if steps were failing, you can use the `always` keyword.

The keyword will not overwrite the job status, i.e. it will still be reported as failed, but the step will be executed.

```yaml
scans:
  example:
    # rest of the fields
    steps:
      # Ensure that step fails
      - run: exit 1
        shell: bash
      - if: always
        run: echo "If you need to do something, for example, notify your own app, you can do it here"
        shell: bash
```

### Download scans, calculate the diff and run the tool on the diff only

To download scans that you depend on, you should probably use the `bh` tool. You can write your own easily, but `bh` is the official CLI tool and will be maintained and worked on continuously.

That being said, let's again start with a complicated example. Our objective in this example is to:

1. Let's say you want to run `subfinder`. Next stage, you want to run the `httprobe`.
2. First time subfinder finishes, we need to use the whole result.
3. If the subfinder has 2 successful scans, we want to figure out the diff, and use the diff to run httprobe.

Okay, now let's dive in. Our `subfinder` scan should be fairly simple:

```yaml
scans:
  subfinder:
    on:
      cron: 5 0/12 * * * *
    uploads:
      - subfinder.txt
    steps:
      - run: subfinder -d ${{ vars.domain }} > subfinder.txt
        shell: bash
```

As you can see, we are leveraging the vars context variable to create a generic expression. The purpose of this is so you can create your own workflow templates, change runtime variables in your project specification, and you can re-use the template easily.

Now let's get to the tricky part. Define the expression for the httprobe to run. As we stated previously, the httprobe should run if subfinder has a single scan (first invocation), or there is a diff between 2 successful scans.

The expression for the first invocation is easy: `size(scans.subfinder) == 1`. Now let's add a guard that we want to ensure that we actually want to run httprobe if the `subfinder` has a single result, and it was successful.

To do that, we can be more fancy. We can filter out all scans that were unsuccessful and then check the size.

`size(scans.subfinder.filter(s, s.status == 'succeeded')) == 1`

To break this down, from subfinder jobs, we filter ones that are succeeded. The filter results in a new list with only successful scans. Therefore, if the size of succeeded scans is 1, we need to run the `httprobe` on the entire result.

Okay, this is fine, but we also want to run on the diff. Let's think about this one. The diff exists if the size of the succeeded scans is at least 2, and the last scan (at index 0), and the next to last scan (at index 1) has different `nonce` value.

Let's put this together: `size(scans.subfinder.filter(s, s.status == 'succeeded')) > 1 && scans.subfinder.filter(s, s.status == 'succeeded')[0].nonce != scans.subfinder.filter(s, s.status == 'succeeded')[1].nonce`

This looks verbose, but it is basically the same. Filter out the succeeded scans, take the element at index and check its `nonce` value.

Now let's put this together. We want to run if there is 1 successful scan, **or** there is a diff:

```yaml
scans:
  subfinder:
    # ...
  httprobe:
    on:
      expr: |
        size(scans.subfinder.filter(s, s.status == 'succeeded')) == 1
        || (size(scans.subfinder.filter(s, s.status == 'succeeded')) > 1 
            && scans.subfinder.filter(s, s.status == 'succeeded')[0].nonce != scans.subfinder.filter(s, s.status == 'succeeded')[1].nonce)
```

Next step, we want to download required files and do our job. If you notice, we always need the result of the latest scan, so let's start there:

```yaml
run: |
  mkdir first && cd first
  bh job download -p ${{ job.id }} -w ${{ workflow.id }} -r ${{ revision.id }} -j ${{ scans.subfinder.filter(s, s.status == 'succeeded')[0].id}} -o first.zip
  unzip first.zip
  rm first.zip
shell: bash
```

In this example, we:

1. Created the directory where we want to download the first run
2. Change our working directory to the new one
3. Leverage `bh` tool to download the output of the latest successful scan
4. Unzip the content of the result
5. Remove the zip file because we don't need it anymore.

Now let's get to the trickier part. If we have a scan that we want to diff on, we want to download that one as well:

```yaml
if: size(scans.subfinder.filter(s, s.status == 'succeeded')) > 1
run: |
  mkdir second && cd second
  bh job download -p ${{ job.id }} -w ${{ workflow.id }} -r ${{ revision.id }} -j ${{ scans.subfinder.filter(s, s.status == 'succeeded')[1].id}} -o second.zip
  unzip second.zip
  rm second.zip
shell: bash
```

We need to have a conditional. Otherwise, the expression would fail. Since this step executes only if there are at least 2 successful scans, we are safe to download the one at index 1 (the second successful scan).

Now we are good, but we want to prepare the environment for our `httprobe`. Let's run a conditional step that will run if the second step is successful (i.e., the download of the second result is not skipped).

```yaml
if: steps[1].status == 'succeeded'
run: |
  cat first/subfinder.txt | anew second/subfinder.txt > subdomains.txt
shell: bash
```

This is basically saying, if we have downloaded the second scan, run anew to find added lines, and write it to the subdomains.txt.

But what if this is the first invocation? Then we only have the `first/subfinder.txt`. Easy, if `steps[1].status == 'skipped'`, we simply move the `first/subfinder.txt` to `subdomains.txt`.

```yaml
if: steps[1].status == 'skipped'
run: mv first/subfinder.txt subdomains.txt
shell: bash
```

Now, we are finally in a good state. The file `subdomains.txt` contains subdomains we want to run `httprobe` on. So let's do just that!

```yaml
run: cat subdomains.txt | httprobe > httprobe.txt
shell: bash
```

Our workflow put together now looks like this:

```yaml
scans:
  subfinder:
    on:
      cron: 5 0/12 * * * *
    uploads:
      - subfinder.txt
    steps:
      - run: subfinder -d ${{ vars.domain }} > subfinder.txt
        shell: bash
  httprobe:
    on:
      expr: |
        size(scans.subfinder.filter(s, s.status == 'succeeded')) == 1
        || (size(scans.subfinder.filter(s, s.status == 'succeeded')) > 1 
            && scans.subfinder.filter(s, s.status == 'succeeded')[0].nonce != scans.subfinder.filter(s, s.status == 'succeeded')[1].nonce)
    uploads:
      - httprobe.txt
    steps:
      - run: |
          mkdir first && cd first
          bh job download -p ${{ job.id }} -w ${{ workflow.id }} -r ${{ revision.id }} -j ${{ scans.subfinder.filter(s, s.status == 'succeeded')[0].id}} -o first.zip
          unzip first.zip
          rm first.zip
        shell: bash

      - if: size(scans.subfinder.filter(s, s.status == 'succeeded')) > 1
        run: |
          mkdir second && cd second
          bh job download -p ${{ job.id }} -w ${{ workflow.id }} -r ${{ revision.id }} -j ${{ scans.subfinder.filter(s, s.status == 'succeeded')[1].id}} -o second.zip
          unzip second.zip
          rm second.zip
        shell: bash

      - if: steps[1].status == 'succeeded'
        run: |
          cat first/subfinder.txt | anew second/subfinder.txt > subdomains.txt
        shell: bash

      - if: steps[1].status == 'skipped'
        run: mv first/subfinder.txt subdomains.txt
        shell: bash

      - run: cat subdomains.txt | httprobe > httprobe.txt
        shell: bash
```

## Context variables

Context variables are variables that are pre-populated by the server at the time the job is sent to the runner.

It allows you to create generic scans and run the command based on your new state. The following context variables are available:

- **scans**: Map of scans and their last 10 jobs for each scan
- **project**: Trimmed down project object
- **workflow**: Trimmed down workflow object
- **revision**: Trimmed down revision object
- **vars**: Map of project variables defined in your project settings
- **always**: Evaluates to `true`. Special purpose variable that allows you to run the step even if the job is about to fail.
- **success**: Variable prepended to your expression that holds the current success status of the job.
- **steps**: Gradually populated list of step states.

Let's talk about them all:

### scans

This is basically a map, with scan names used as keys, and job contexts used as values. It looks something similar to this:

```json
{
  "scan1": [], // list of scan objects
  "scan2": [],
  "scan3": []
}
```

The job object contains the following fields:

| Name   | Type           | Required |
| ------ | -------------- | -------- |
| id     | string         | yes      |
| status | string         | yes      |
| nonce  | string or null | no       |


### project

Project is a simple object with the following fields:

| Name   | Type           | Required |
| ------ | -------------- | -------- |
| id     | string         | yes      |

It allows you to use the project id in order to fetch some object, like job result, from the BountyHub API.

### workflow

Workflow is a simple object with the following fields:

| Name   | Type           | Required |
| ------ | -------------- | -------- |
| id     | string         | yes      |

It allows you to use the workflow id in order to fetch some object from the BountyHub API.

### revision

Revision is a simple object with the following fields

| Name   | Type           | Required |
| ------ | -------------- | -------- |
| id     | string         | yes      |

### vars

Vars is the map of key-value pairs that you configured as project variables in your project.

This maps `string -> string`, and looks something like:

```json
{
  "domain": "bountyhub.org",
  "tool_rate": "5",
  "api_key": "api key for your tools if you need one"
}
```

### success

This is a variable that has a bool type, and mutates after each step. Every step `if` is prepended with `success && (YOUR_EXPRESSION_HERE)`.

That means that if any step fails, the `success` will evaluate to `false`, causing steps to be skipped. You don't need to explicitly use this variable, but you should know that it exists.

### always

This is basically a keyword. It is a constant evaluating to `true`, but it has a special meaning. If the value of `if` step expression is `always`, this step will be always executed. The server will not prepend the `success`. Keep in mind that the value cannot be something like: `if: always && (steps[0].status == 'succeeded')`. There are 2 reasons for this:

1. It doesn't make sense to write something like `if: true && (expr)`. It effectively is the same as writing `if: expr`.
2. The `always` only makes sense if you want to **always** run this :).